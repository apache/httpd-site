<!-- HTML header for doxygen 1.9.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libapreq2-2.17: APR::Request</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="customdoxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0" width="100%">
 <tbody>
 <tr style="height: 56px;">
<!--
  <td id="projectlogo"><img alt="Logo" src="feather.png"/></td>
-->
<!--
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">libapreq2
   < !--BEGIN PROJECT_NUMBER-- >&#160;<span id="projectnumber">2.17</span>< !--END PROJECT_NUMBER-- >
   </div>
   < !--BEGIN PROJECT_BRIEF-- ><div id="projectbrief"></div>< !--END PROJECT_BRIEF-- >
  </td>
-->
  <td>
    <div id="page-header">
      <p class="menu">
        <a href="https://www.apache.org/">Apache Software Foundation</a> &gt;
        <a href="https://httpd.apache.org">HTTP Server Project</a> &gt;
        <a href="https://httpd.apache.org/apreq/">Request Library Subproject</a>
      </p>
      <p class="apache">Apache HTTP Server Request Library - 2.17</p>
      <img alt="" src="feather.png" />
    </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">APR::Request<div class="ingroups"><a class="el" href="group__apreq__lang.html">Language Bindings</a> &raquo; <a class="el" href="group__apreq__xs.html">Perl</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for APR::Request:</div>
<div class="dyncontent">
<div class="center"><img src="group__apreq__xs__apr__request.png" border="0" usemap="#agroup____apreq____xs____apr____request" alt=""/></div>
<map name="agroup____apreq____xs____apr____request" id="agroup____apreq____xs____apr____request">
<area shape="rect" href="group__apreq__xs.html" title="XS Modules." alt="" coords="5,5,52,31"/>
<area shape="rect" title=" " alt="" coords="100,5,209,31"/>
</map>
</div>




<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNOPSIS">SYNOPSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a></li>
  <li><a href="#METHODS">METHODS</a>
    <ul>
      <li><a href="#handle">handle</a></li>
    </ul>
  </li>
  <li><a href="#METHODS1">METHODS</a>
    <ul>
      <li><a href="#pool">pool</a></li>
      <li><a href="#bucket_alloc">bucket_alloc</a></li>
      <li><a href="#jar_status">jar_status</a></li>
      <li><a href="#args_status">args_status</a></li>
      <li><a href="#body_status">body_status</a></li>
      <li><a href="#param_status">param_status</a></li>
      <li><a href="#parse">parse</a></li>
      <li><a href="#jar">jar</a></li>
      <li><a href="#args">args</a></li>
      <li><a href="#body">body</a></li>
      <li><a href="#param">param</a></li>
      <li><a href="#upload">upload</a></li>
      <li><a href="#read_limit">read_limit</a></li>
      <li><a href="#brigade_limit">brigade_limit</a></li>
      <li><a href="#temp_dir">temp_dir</a></li>
      <li><a href="#disable_uploads">disable_uploads</a></li>
      <li><a href="#upload_hook">upload_hook</a></li>
      <li><a href="#import">import</a></li>
    </ul>
  </li>
  <li><a href="#SUBROUTINES">SUBROUTINES</a>
    <ul>
      <li><a href="#encode">encode</a></li>
      <li><a href="#decode">decode</a></li>
    </ul>
  </li>
  <li><a href="#SUBCLASSING">SUBCLASSING</a></li>
  <li><a href="#METHODS2">METHODS</a>
    <ul>
      <li><a href="#cookie_class">cookie_class</a></li>
      <li><a href="#get">get</a></li>
      <li><a href="#FETCH">FETCH</a></li>
      <li><a href="#EXISTS">EXISTS</a></li>
      <li><a href="#FIRSTKEY">FIRSTKEY</a></li>
      <li><a href="#NEXTKEY">NEXTKEY</a></li>
      <li><a href="#do">do</a></li>
    </ul>
  </li>
  <li><a href="#METHODS3">METHODS</a>
    <ul>
      <li><a href="#param_class">param_class</a></li>
      <li><a href="#get1">get</a></li>
      <li><a href="#FETCH1">FETCH</a></li>
      <li><a href="#EXISTS1">EXISTS</a></li>
      <li><a href="#NEXTKEY1">NEXTKEY</a></li>
      <li><a href="#FIRSTKEY1">FIRSTKEY</a></li>
      <li><a href="#do1">do</a></li>
    </ul>
  </li>
  <li><a href="#SEE-ALSO">SEE ALSO</a></li>
  <li><a href="#COPYRIGHT">COPYRIGHT</a></li>
</ul>

<h1 id="NAME">NAME</h1>

<p>APR::Request - wrapper for libapreq2&#39;s module/handle API.</p>

<h1 id="SYNOPSIS">SYNOPSIS</h1>

<pre><code>use APR::Request;

$req = APR::Request::Custom-&gt;handle($pool,
                                    &quot;foo=arg1&amp;bar=arg2&quot;,
                                    &quot;apache=quux&quot;,
                                     $parser, 1e6, $bb);
$param = $req-&gt;param(&quot;foo&quot;);
$cookie = $req-&gt;jar(&quot;apache&quot;);</code></pre>

<h1 id="DESCRIPTION">DESCRIPTION</h1>

<p>The <code>APR::Request</code> module provides the base methods for interfacing with libapreq2&#39;s module API. It also provides a few utility functions and constants.</p>

<p>This manpage documents version 2.18 of the APR::Request, APR::Request::Custom, APR::Request::Cookie::Table, and APR::Request::Param::Table packages.</p>

<h1 id="METHODS">METHODS</h1>

<p>APR::Request::Custom - derived from APR::Request.</p>

<h2 id="handle">handle</h2>

<pre><code>APR::Request::Custom-&gt;handle($pool,
                             $query_string,
                             $cookie_header,
                             $parser,
                             $read_limit,
                             $brigade)</code></pre>

<p>Creates a new APR::Request::Custom object. The $query_string and $cookie_headers are immediately parsed into the <code>args</code> and <code>jar</code> tables. The $parser is an APR::Request::Parser object which is invoked when fetching <code>body</code> entries from the $brigade. The $read_limit represents the maximum number of bytes this handle may feed into the parser.</p>

<h1 id="METHODS1">METHODS</h1>

<p>APR::Request</p>

<h2 id="pool">pool</h2>

<pre><code>$req-&gt;pool()</code></pre>

<p>Returns the APR::Pool object associated to this handle.</p>

<h2 id="bucket_alloc">bucket_alloc</h2>

<pre><code>$req-&gt;bucket_alloc()</code></pre>

<p>Returns the APR::BucketAlloc object associated to this handle.</p>

<h2 id="jar_status">jar_status</h2>

<pre><code>$req-&gt;jar_status()</code></pre>

<p>Returns the final status code of the handle&#39;s cookie header parser.</p>

<h2 id="args_status">args_status</h2>

<pre><code>$req-&gt;args_status()</code></pre>

<p>Returns the final status code of the handle&#39;s query-string parser.</p>

<h2 id="body_status">body_status</h2>

<pre><code>$req-&gt;body_status()</code></pre>

<p>Returns the final status code of the handle&#39;s body parser.</p>

<h2 id="param_status">param_status</h2>

<pre><code>$req-&gt;param_status()</code></pre>

<p>Returns <code>($req-&gt;args_status, $req-&gt;body_status)</code> in list context; otherwise returns <code>$req-&gt;args_status || $req-&gt;body_status</code>.</p>

<h2 id="parse">parse</h2>

<pre><code>$req-&gt;parse()</code></pre>

<p>Parses the jar, args, and body tables. Returns <code>$req-&gt;jar_status, $req-&gt;args_status, $req-&gt;body_status</code>.</p>

<pre><code>@status = $req-&gt;parse;
ok @status == 3;
ok $status[0] == $req-&gt;jar_status;
ok $status[1] == $req-&gt;args_status;
ok $status[2] == $req-&gt;body_status;</code></pre>

<h2 id="jar">jar</h2>

<pre><code>$req-&gt;jar()
$req-&gt;jar($key)</code></pre>

<p>With no arguments, this method returns a tied APR::Request::Cookie::Table object (or undef if the &quot;Cookie&quot; header is absent) in scalar context, or the names (in order, with repetitions) of all the parsed cookies.</p>

<p>With the <code>$key</code> argument, in scalar context this method fetches the first matching cookie. In list context it returns all matching cookies. The returned cookies are the values as they appeared in the incoming Cookie header.</p>

<p>jar() will throw an APR::Request::Error object whenever jar_status() is non-zero and the return value is potentially invalid (eg <code>scalar $req-&gt;jar($key)</code> will not die if the desired cookie was successfully parsed).</p>

<pre><code>$jar = $req-&gt;jar;
@cookie_names = $req-&gt;jar;
ok $jar-&gt;isa(&quot;APR::Request::Cookie::Table&quot;);
ok shift @cookie_names eq $_ for keys %$jar;

$cookie = $req-&gt;jar(&quot;apache&quot;);
@cookies = $req-&gt;jar(&quot;apache&quot;);</code></pre>

<h2 id="args">args</h2>

<pre><code>$req-&gt;args()
$req-&gt;args($key)</code></pre>

<p>With no arguments, this method returns a tied APR::Request::Param::Table object (or undef if the query string is absent) in scalar context, or the names (in order, with repetitions) of all the parsed query-string arguments.</p>

<p>With the <code>$key</code> argument, in scalar context this method fetches the first matching query-string arg. In list context it returns all matching args.</p>

<p>args() will throw an APR::Request::Error object whenever args_status() is non-zero and the return value is potentially invalid (eg <code>scalar $req-&gt;args($key)</code> will not die if the desired query argument was successfully parsed).</p>

<pre><code>$args = $req-&gt;args;
@arg_names = $req-&gt;args;
ok $args-&gt;isa(&quot;APR::Request::Param::Table&quot;);
ok shift @arg_names eq $_ for keys %$args;

$foo = $req-&gt;args(&quot;foo&quot;);
@bar = $req-&gt;args(&quot;bar&quot;);</code></pre>

<h2 id="body">body</h2>

<pre><code>$req-&gt;body()
$req-&gt;body($key)</code></pre>

<p>With no arguments, this method returns a tied APR::Request::Param::Table object (or undef if the request body is absent) in scalar context, or the names (in order, with repetitions) of all the parsed cookies.</p>

<p>With the <code>$key</code> argument, in scalar context this method fetches the first matching body param. In list context it returns all matching body params.</p>

<p>body() will throw an APR::Request::Error object whenever body_status() is non-zero and the return value is potentially invalid (eg <code>scalar $req-&gt;body($key)</code> will not die if the desired body param was successfully parsed).</p>

<pre><code>$body = $req-&gt;body;
@body_names = $req-&gt;body;
ok $body-&gt;isa(&quot;APR::Request::Param::Table&quot;);
ok shift @body_names eq $_ for keys %$body;

$alpha = $req-&gt;body(&quot;alpha&quot;);
@beta = $req-&gt;body(&quot;beta&quot;);</code></pre>

<h2 id="param">param</h2>

<pre><code>$req-&gt;param()
$req-&gt;param($key)</code></pre>

<p>With no arguments, this method returns a tied APR::Request::Param::Table object (or undef, if the query string and request body are absent) in scalar context, or the names (in order, with repetitions) of all the incoming (args + body) params.</p>

<p>With the <code>$key</code> argument, in scalar context this method fetches the first matching param. In list context it returns all matching params.</p>

<p>param() will throw an APR::Request::Error object whenever param_status() is non-zero and the return value is potentially invalid (eg <code>scalar $req-&gt;param($key)</code> will not die if the desired param was successfully parsed).</p>

<pre><code>$param = $req-&gt;param;
@param_names = $req-&gt;param;
ok $param-&gt;isa(&quot;APR::Request::Param::Table&quot;);
ok shift @param_names eq $_ for keys %$param;

$foo = $req-&gt;param(&quot;foo&quot;);
@foo = $req-&gt;param(&quot;foo&quot;);</code></pre>

<h2 id="upload">upload</h2>

<pre><code>$req-&gt;upload()
$req-&gt;upload($key)</code></pre>

<p>With no arguments, this method returns a tied APR::Request::Param::Table object (or undef if the request body is absent) in scalar context (whose entries are APR::Request::Param objects), or the names (in order, with repetitions) of all the incoming uploads.</p>

<p>With the <code>$key</code> argument, in scalar context this method fetches the first matching upload. In list context it returns all matching uploads. The return values are APR::Request::Param objects.</p>

<p>upload() will throw an APR::Request::Error object whenever body_status() is non-zero.</p>

<pre><code>$uploads = $req-&gt;upload;
@upload_names = $req-&gt;upload;
ok $uploads-&gt;isa(&quot;APR::Request::Param::Table&quot;);
ok shift @upload_names eq $_ for keys %$uploads;
ok $_-&gt;upload for values %$uploads;

$up = $req-&gt;upload(&quot;beta&quot;);
@ups = $req-&gt;upload(&quot;beta&quot;);
ok $_-&gt;isa(&quot;APR::Request::Param&quot;) for $up, @ups;
ok $_-&gt;upload for $up, @ups;</code></pre>

<h2 id="read_limit">read_limit</h2>

<pre><code>$req-&gt;read_limit()
$req-&gt;read_limit($set)</code></pre>

<p>Get/set the read limit, which controls the total amount of bytes that can be fed to the current parser.</p>

<h2 id="brigade_limit">brigade_limit</h2>

<pre><code>$req-&gt;brigade_limit()
$req-&gt;brigade_limit($set)</code></pre>

<p>Get/set the brigade_limit for the current parser. This limit determines how many bytes of a file upload that the parser may spool into main memory. Uploads exceeding this limit are written directly to disk.</p>

<h2 id="temp_dir">temp_dir</h2>

<pre><code>$req-&gt;temp_dir()
$req-&gt;temp_dir($set)</code></pre>

<p>Get/set the spool directory for uploads which exceed the configured brigade_limit.</p>

<h2 id="disable_uploads">disable_uploads</h2>

<pre><code>$req-&gt;disable_uploads()</code></pre>

<p>Engage the disable_uploads hook for this request.</p>

<h2 id="upload_hook">upload_hook</h2>

<pre><code>$req-&gt;upload_hook($callback)</code></pre>

<p>Add an upload hook callback for this request. The arguments to the $callback sub are ($upload, $new_data).</p>

<h2 id="import">import</h2>

<p>Exports a list of subs into the caller&#39;s package.</p>

<h1 id="SUBROUTINES">SUBROUTINES</h1>

<p>APR::Request</p>

<h2 id="encode">encode</h2>

<pre><code>encode($string)</code></pre>

<p>Exportable sub which returns the url-encoded form of <code>$string</code>.</p>

<h2 id="decode">decode</h2>

<pre><code>decode($string)</code></pre>

<p>Exportable sub which returns the url-decoded form of <code>$string</code>.</p>

<h1 id="SUBCLASSING">SUBCLASSING</h1>

<p>APR::Request</p>

<p>If the instances of your subclass are hash references then you can actually inherit from APR::Request as long as the APR::Request object is stored in an attribute called &quot;r&quot; or &quot;_r&quot;. (The APR::Request class effectively does the delegation for you automagically, as long as it knows where to find the APR::Request object to delegate to.) For example:</p>

<pre><code>package MySubClass;
use APR::Request::Custom;
our @ISA = qw(APR::Request);
sub new {
    my($class, @args) = @_;
    return bless { r =&gt; APR::Request::Custom-&gt;handle(@args) }, $class;
}</code></pre>

<h1 id="METHODS2">METHODS</h1>

<pre><code>APR::Request::Cookie::Table - read-only version of APR::Table.</code></pre>

<p>Tables in this class normally arise from calls to <code>APR::Request::jar()</code>.</p>

<h2 id="cookie_class">cookie_class</h2>

<pre><code>$table-&gt;cookie_class()
$table-&gt;cookie_class($set)</code></pre>

<p>Get/set the class each table element is blessed into during a <a>get</a> or <a>FETCH</a> call. If defined, the class must be derived from APR::Request::Cookie. When called with $set, it returns the $table. Otherwise it returns the name of the current class, or undef if no cookie class is defined.</p>

<h2 id="get">get</h2>

<pre><code>$table-&gt;get($key)</code></pre>

<p>Same as FETCH.</p>

<h2 id="FETCH">FETCH</h2>

<pre><code>$table-&gt;FETCH($key)</code></pre>

<p>In scalar context, this returns the first value matching $key (note: see NEXTKEY for additional notes). The match is always case-insensitive. In list context, this returns all matching values. Note: the type of the return values depends on the table&#39;s current cookie_class.</p>

<h2 id="EXISTS">EXISTS</h2>

<p>Synonym for <code>defined</code>; these tables are not allowed to contain undefined values. Since these are constant tables, they don&#39;t autovivify either.</p>

<h2 id="FIRSTKEY">FIRSTKEY</h2>

<pre><code>$table-&gt;FIRSTKEY()</code></pre>

<p>Returns the first key in the table.</p>

<h2 id="NEXTKEY">NEXTKEY</h2>

<pre><code>$table-&gt;NEXTKEY()</code></pre>

<p>Returns the next key in the table. For perl 5.8+, if the key is multivalued, a subsequent FETCH on this key will return the corresponding value, until either NEXTKEY or FIRSTKEY is invoked again. For perl 5.6, FETCH always returns the first value.</p>

<h2 id="do">do</h2>

<pre><code>$table-&gt;do($callback, @keys)</code></pre>

<p>Same as APR::Table::do; iterates over the table calling $callback-&gt;($key, $value) for each matching @keys. If @keys is empty, this iterates over the entire table.</p>

<p>Note: The type of $value inserted into the callback depends on the table&#39;s current cookie_class.</p>

<h1 id="METHODS3">METHODS</h1>

<p>APR::Request::Param::Table</p>

<h2 id="param_class">param_class</h2>

<pre><code>$table-&gt;param_class()
$table-&gt;param_class($set)</code></pre>

<p>Get/set the class each table element is blessed into during a <code>get</code> or <code>FETCH</code> call. If defined, the class must be derived from APR::Request::Param. When called with $set, it returns the $table. Otherwise it returns the name of the current class, or undef if no param class is defined.</p>

<h2 id="get1">get</h2>

<pre><code>$table-&gt;get($key)</code></pre>

<p>Same as FETCH.</p>

<h2 id="FETCH1">FETCH</h2>

<pre><code>$table-&gt;FETCH($key)</code></pre>

<p>In scalar context, this returns the first value matching $key (see NEXTKEY for additional notes on this). The match is always case-insensitive. In list context, this returns all matching values. Note: the type of the return values depends on the table&#39;s current param_class.</p>

<h2 id="EXISTS1">EXISTS</h2>

<p>Synonym for <code>defined</code>; these tables are not allowed to contain undefined values. Since these are constant tables, they don&#39;t autovivify either.</p>

<h2 id="NEXTKEY1">NEXTKEY</h2>

<pre><code>$table-&gt;NEXTKEY()</code></pre>

<p>Returns the next key in the table. For perl 5.8+, if the key is multivalued, a subsequent FETCH on this key will return the corresponding value, until either NEXTKEY or FIRSTKEY is invoked again. For perl 5.6, FETCH always returns the first value.</p>

<h2 id="FIRSTKEY1">FIRSTKEY</h2>

<pre><code>$table-&gt;FIRSTKEY()</code></pre>

<p>Returns the first key in the table.</p>

<h2 id="do1">do</h2>

<pre><code>$table-&gt;do($callback, @keys)</code></pre>

<p>Same as APR::Table::do; iterates over the table calling $callback-&gt;($key, $value) for each matching @keys. If @keys is empty, this iterates over the entire table.</p>

<p>Note: The type of $value inserted into the callback depends on the table&#39;s current value_class.</p>

<h1 id="SEE-ALSO">SEE ALSO</h1>

<p><a>APR::Request::Error</a>, <a>APR::Request::Param</a>, <a>APR::Request::Cookie</a>, <a>APR::Request::Parser</a></p>

<h1 id="COPYRIGHT">COPYRIGHT</h1>

<pre><code>Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the &quot;License&quot;); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.</code></pre>


 </div><!-- contents -->
<!-- HTML footer for doxygen 1.9.1-->
<!-- start footer part -->
<hr class="footer"/>
<table class="footer">
  <td>
    <address class="footer_left"><small>
    Copyright &copy; 2003-2022 <a href="https://www.apache.org">The Apache Software Foundation</a>.<br/>
    See <a href="apreq_license.html">LICENSE</a>.
    </small></address>
  </td>
  <td>
    <address class="footer"><small>
    Generated on Sat Sep 3 2022 17:23:06 for libapreq2 by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
    </small></address>
  </td>
</table>
</body>
</html>
